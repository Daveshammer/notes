**`final`和`override`的作用？`final`为什么能提高代码执行效率？**

- `override`：保护派生类中声明的重载函数，与基类的虚函数有相同的签名，用于编译器代码检查

- `final`：阻止类的进一步派生；阻止虚函数的进一步重写，这样可以在编译期间确定虚函数的调用版本，避免了动态绑定的开销

**`static`的作用**

- 在函数内部，将局部变量变为静态变量，使其在函数调用之间保持值不变。
- 在类中，创建静态成员变量和静态成员函数，使其属于类本身而不是实例。
- 限制对静态变量、静态函数或静态类的访问范围或实例化能力。

**为什么`noexcept`能提高性能**

为实现异常捕获的功能，C++引入了“**栈回退**”机制，编译器会为函数额外生成“栈回退”的代码，使用`noexcept`可以避免生成额外的代码来处理异常情况

**`new`，`placement new`，`operator new`的区别？如何把对象`new`在栈上**

- `operator new`作用是分配一块内存，`placement new`作用是在已分配内存地址处，创建一个对象，`new`的作用则等于`operator new` + `placement new`。

- 先在栈上声明一个数组，然后通过`placement new` 在这段地址处创建对象，这就实现了在栈上`new`一个对象。

**声明和定义的作用，从编译角度说明？**

声明的作用：第一，提供链接时需要的符号信息，这些信息存储在目标文件的重定位表和符号表当中；第二，提供类型大小信息，C++采取的是单文件编译策略，当不知道某个符号对应类型的定义的时候，需要在链接前预留出合适大小的内存空间，供链接时填充。

**构造函数可以是虚函数吗？类成员函数模板可以是虚函数吗？**

- 构造函数不能是虚函数，这是因为构造函数是用来创建对象的，在创建对象期间，存放虚函数地址的虚表还没有创建完成，如果直接调用虚函数会引发异常。

- 类成员函数模板不能是虚函数，因为C++在链接前是不知道成员函数模板被实例化多少次的，这就会导致编译器无法在编译期间确定虚表的大小。

**成员函数指针和普通函数指针区别？**

通常来说，函数指针的长度等于机器字长，而成员函数指针长度比函数指针更长，其内部存放了对象地址和成员函数地址信息。在没有给出对象地址的情况下，调用成员函数指针会报错。

**`inline`的作用和原理？**

- C++17以前，`inline`关键字主要有两个作用：第一，作为内联优化建议，只不过是否展开函数还是由编译器决定；第二，解决符号重定义问题，不同文件内定义了同签名的函数，若被inline关键字修饰，则不会引发符号重定义错误。

- c++17开始，inline只保留第二个作用，若用户希望函数内联展开，则可以使用`__attribute((always_inline))__` 关键字，它是 GCC 和 Clang 中的一个扩展，用于强制内联函数。。  

- 原理上，第一，内联展开相比于普通函数调用，少了函数上下文压栈的过程，因此效率更高，缺点就是容易引起代码膨胀。第二，被`inline`关键字修饰的函数名，编译期间会被标记为weak符号，链接目标文件的时候，多个同签名weak符号不会引发编译器报错，运行期间，会选取其中一个函数进行调用。

**可以在运行时访问private成员吗？**

可以，访问权限关键字只在编译期有效，运行期是没有访问权限关键字这些概念的。

**动态库和静态库的区别？知道动态库延迟加载优化吗？**

链接动态库和静态库的时候，静态库会被复制到可执行程序当中，而动态库不会。相比动态库，静态库的执行效率更高，但占用磁盘空间更多，不方便更新。动态库的延迟加载指的是，在运行时按需加载动态链接库中的函数和数据，而不是在启动的时候加载库函数和数据，从而降低启动时间，在linux系统下，延迟加载是通过PLT表和GOT表配合实现的。

**可变参数函数的实现原理？**

可变参数函数在编译期间，可以获取到实际参数数量和参数类型；可变参数函数运行的时候，会根据编译期间获取到的类型和大小信息，分配相应大小的栈空间，把参数按照从右到左的顺序依次压入当前函数的栈帧；当前栈帧的地址完全是可以获取到的，出于安全考虑，获取参数值前，需要通过`va_start`把参数值拷贝到`va_list`指向的堆空间，遍历`va_list`就可以获取到每个参数的值了。

**`any`可以替代`void*`吗？**

- 可以，与`void*`相比，`any`优势在于：第一，其它类型被转换成`void*`后，类型信息会发生丢失，而`any`会存储类型信息，进行类型转化时更安全；第二，`any`析构时，会自动析构堆上的对象，而`void*`需要手动管理内存。

- 劣势在于：第一，`any`内存占用更高；第二，进行类型转化，会进行类型检查，效率更低，但这点劣势可忽略不计。

**`variant`可以替代`union`吗？**

可以，`variant`通过可变参数模板和递归`union`的方式实现，`variant`实例化对象内存放有数据类型信息。相比于`union`，`variant`优势在于：第一，可以存储复杂类型，而`union`只能存储trivial类型；第二，`variant`存储了数据的类型信息，可以进行安全的类型转换。劣势在于，内存更大、访问效率更低。

**`sizeof(function)`大小是多少？`function`的实现方式？**

`std::function`的大小等于2个机器字长，这是因为`std::function`可以封装任何可调用对象，其中普通函数指针长度为1个机器字长，成员函数指针长度为2个机器字长，因此为了能够封装任何可调用对象，其内存大小为2个机器字长。`std::function`内部封装有一个函数指针指向可调用对象，然后重载实现构造函数、`=`运算符、`()`运算符。

**`forward`和`move`的作用？**

- `move`有两个作用，第一，进行赋值或者拷贝的时候调用对象的移动赋值函数或者移动构造函数，把原对象在堆上的资源移为己有；第二，告诉编译器调用参数为右值引用类型的函数。

- `forward`作用是告诉编译器，是调用参数类型为左值引用类型的函数，还是调用参数类型为右值类型的函数。如果没有`move`和`forward`，任何实参传递给函数后，都会变成左值类型，这就会造成参数类型为右值引用的函数永远无法被调用。

 **模板的全特化和偏特化是什么？**

首先，模板函数只有全特化，没有偏特化，模板类有全特化和偏特化。模板全特化指的是，在元编程中给定所有模板参数的具体类型；模板偏特化也称为部分特化，指的是在元编程中给定部分模板参数的具体类型。引入特化和偏特化是为了给特定的类型提供单独的实现。

**模板的匹配规则是什么？**

- 模板函数的匹配顺序是：首先根据函数名进行匹配；若找到多个函数名匹配的模板，再根据参数列表进行匹配，这种匹配过程被叫做重载决议。

- 模板类的匹配顺序是：首先根据类名进行匹配；若找到多个类名匹配的模板，再按照全特化、偏特化、通用模板的的优先级进行匹配。

**`push_back()`和`emplace_back()`区别？**

假设容器内存放的元素类型是`T`，其定义了`T(int)`构造函数，`T(const T&)`拷贝构造，`T(T&&)`移动构造函数。首先，`push_back()`是单参数函数，参数类型是`const T&`或者`T&&`，`emplace_back()`是不定参数函数，其参数列表必须和T的普通构造函数、拷贝构造函数或者移动构造函数的参数相同；第二，`emplace_back()`通过可变参数成员函数模板实现，其编译时长比`push_back()`更长；第三，`push_back()`和`emplace_back()`的执行效率完全相同，只有一种例外情况：`push_back(2)`比`emplace_back(2)`多执行一次普通构造函数，因为前者需要通过构造函数把`2`转化为`T`类型，然后调用`push_back()`函数。

 **线程和协程的区别？为什么引入协程？**

- 两者区别是，第一，线程的调度需要切换到内核态，由操作系统完成，协程的调度在用户态完成，由用户程序程序进行调度；

- 第二，抢占式协程和抢占式线程的实现原理不同，抢占式协程由编译器插入时间片或者由操作系统信号实现，线程的抢占通过时间片中断实现。引入协程是为了实现异步非阻塞编程，传统的线程在异步资源返回前，往往会阻塞当前线程，但是引入协程后，在异步资源返回前，当前线程不必阻塞，而可以执行其它协程中的任务。

**条件变量的实现原理？**

互斥锁只能实现对资源的互斥访问，而不能实现线程同步，引入条件变量就是为了实现线程同步。条件变量是基于互斥锁和等待队列实现的，`wait()`调用后，若发现条件变量没有被占用，则继续执行，若发现条件变量被占用，则释放锁并阻塞当前线程，把线程放到等待队列上；`notify()`调用后，会唤醒阻塞的线程。

**条件变量和信号量区别？**

首先，信号量是通过互斥锁、等待队列、计数器实现的，条件变量是通过互斥锁和等待队列实现，没有计数功能；第二，信号量既可以充当互斥锁，也可以充当条件变量；第三，如果等待队列上没有任务，信号量调用notify后，信号会被保存，条件变量调用notify后，信号会丢失；通过信号量可以实现线程同步，条件变量需要和互斥锁配合使用才能实现线程同步，前者使用起来更简单，后者内存占用和性能更好。

**为什么要在父线程执行`detach()`或者`join()`？**

调用`detach()`或者`join()`后，子线程的状态会从`unjoinable`变为`joinable`，父线程执行结束的时候，若发现子线程状态是`joinable`则会调用`terminate()`终止子线程，反之则什么也不做。在父进程内不调用`detach()`或者`join()`，如果父线程执行完子线程还没执行完，会导致子线程异常终止。
